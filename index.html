<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
    <title>AR Navigation Demo</title>

    <script src="https://aframe.io/releases/1.0.4/aframe.min.js"></script>
    <script src="https://raw.githack.com/AR-js-org/AR.js/master/aframe/build/aframe-ar-nft.js"></script>

    <style>
      #status {
        position: fixed;
        top: 10px;
        left: 10px;
        background: rgba(0,0,0,0.6);
        color: white;
        padding: 6px 10px;
        font-size: 14px;
        z-index: 9999;
        white-space: pre-line;
      }
    </style>
  </head>

  <body style="margin:0; overflow:hidden;">
    <div id="status">ğŸ“ ã‚¿ãƒƒãƒ—ã—ã¦ä½ç½®æƒ…å ±ã‚’æœ‰åŠ¹åŒ–ã—ã¦ãã ã•ã„</div>

    <a-scene embedded arjs="sourceType: webcam; debugUIEnabled: true;">
      <!-- å¸¸ã«2må…ˆã«ç®±ã‚’è¡¨ç¤º -->
      <a-box id="arrow" color="#4CC3D9" scale="0.5 0.5 2" position="0 0 -2"></a-box>
      <a-camera></a-camera>
    </a-scene>

    <script>
      const statusEl = document.getElementById("status");
      const arrow = document.getElementById("arrow");

      // ğŸ¯ ç›®çš„åœ°ï¼ˆä¾‹: é©å½“ãªåº§æ¨™ï¼‰
      const targetLat = 35.83841;
      const targetLon = 139.55606;

      // åº¦â†’ãƒ©ã‚¸ã‚¢ãƒ³
      const toRad = (deg) => deg * Math.PI / 180;

      // è·é›¢ã¨æ–¹ä½è§’ã‚’è¨ˆç®—
      function computeDistanceAndBearing(lat1, lon1, lat2, lon2) {
        const R = 6378137; // åœ°çƒåŠå¾„[m]
        const dLat = toRad(lat2 - lat1);
        const dLon = toRad(lon2 - lon1);
        const a = Math.sin(dLat/2)**2 +
                  Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) * Math.sin(dLon/2)**2;
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
        const distance = R * c;

        // æ–¹ä½è§’ï¼ˆåŒ—=0Â°ã‹ã‚‰æ™‚è¨ˆå›ã‚Šï¼‰
        const y = Math.sin(dLon) * Math.cos(toRad(lat2));
        const x = Math.cos(toRad(lat1))*Math.sin(toRad(lat2)) -
                  Math.sin(toRad(lat1))*Math.cos(toRad(lat2))*Math.cos(dLon);
        const bearing = (Math.atan2(y, x) * 180 / Math.PI + 360) % 360;

        return {distance, bearing};
      }

      // æ–¹ä½ã‚’ã‚³ãƒ³ãƒ‘ã‚¹é¢¨ã«è¡¨ç¾
      function bearingToText(bearing) {
        const dirs = ["åŒ—","åŒ—æ±","æ±","å—æ±","å—","å—è¥¿","è¥¿","åŒ—è¥¿"];
        return dirs[Math.round(bearing / 45) % 8];
      }

      document.body.addEventListener("click", () => {
        if (navigator.geolocation) {
          navigator.geolocation.watchPosition(
            (pos) => {
              const myLat = pos.coords.latitude;
              const myLon = pos.coords.longitude;

              const {distance, bearing} = computeDistanceAndBearing(myLat, myLon, targetLat, targetLon);

              // ç®±ã‚’ç›®çš„åœ°æ–¹å‘ã«å›è»¢ï¼ˆYè»¸ã‚’å›ã™ï¼‰
              arrow.setAttribute("rotation", `0 ${bearing} 0`);

              // UIæ›´æ–°
              statusEl.innerText =
                `ç¾åœ¨åœ°: ${myLat.toFixed(5)}, ${myLon.toFixed(5)}\n` +
                `ç›®çš„åœ°ã¾ã§: ç´„${distance.toFixed(1)}m (${bearingToText(bearing)})`;
            },
            (err) => {
              statusEl.innerText = "âŒ ä½ç½®æƒ…å ±ã‚¨ãƒ©ãƒ¼: " + err.message;
            },
            { enableHighAccuracy: true, timeout: 5000, maximumAge: 0 }
          );
        }
      });
    </script>
  </body>
</html>
